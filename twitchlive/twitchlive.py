import asyncio
import hashlib
from collections import defaultdict
from copy import deepcopy
from typing import Optional, Tuple, Dict, Any, List

import discord
from redbot.core import Config, commands, checks
from redbot.core.bot import Red
from redbot.core.commands import Context

from twitchlive.models.common_models import StreamAnnouncement
from twitchlive.twitchapi.twichobjects import TwitchUser
from .twitchapi import TwitchApi

class TwitchLive(object):

    MONITOR_PROCESS_INTERVAL = 5
    TWITCH_API_THROTTLE = 0.2
    COG_CONFIG_SALT = "twitch.tv/seputaes"

    def __init__(self, bot: Red):
        self.bot = bot
        self.config = self.__setup_config()

        self.twitch_api = None  # type: Optional[TwitchApi]

        self.twitch_config_cache = {}
        self.announce_cache = {}
        self.already_announced_cache = set()

        asyncio.ensure_future(self.__init_cache_and_api())
        asyncio.ensure_future(self.__monitor_streams())

    def __setup_config(self):
        """
        Generates an awaitable Red configuration object unique to this module.
        :return: awaitable Config
        """
        encoded_bytes = (self.COG_CONFIG_SALT + self.__class__.__name__).encode()
        identifier = int(hashlib.sha512(encoded_bytes).hexdigest(), 16)

        config = Config.get_conf(self, identifier=identifier, force_registration=False)
        self.__register_config_entities(config)

        return config

    @staticmethod
    def __register_config_entities(config: Config):
        """
        Register the configuration entities which will be used by the Cog.
        :param config: Config object generated by Config.get_conf()
        :return: None, modifies Config object in place.
        """
        config.register_global(twitch_config={})
        config.register_guild(announcements={})
        config.register_guild(already_announced=[])

    async def __init_cache_and_api(self):
        await self.bot.wait_until_ready()

        # Cache the guild announcements on load
        guilds = await self.config.all_guilds()

        streamer_checks = defaultdict(dict)

        for guild_id, guild_dict in guilds.items():
            announcements = guild_dict.get('announcements', {})
            already_announced = guild_dict.get('already_announced', [])


            for user_id, metadata in announcements.items():
                streamer_checks[str(guild_id)][str(user_id)] = metadata

            self.already_announced_cache | set(already_announced)

        self.announce_cache = streamer_checks

        # cache already announced streams


        # cache twitch configuration
        self.twitch_config_cache = await self.config.twitch_config()

        # init the api
        self.__init_twitch_api()

    def __init_twitch_api(self):
        client_id = self.twitch_config_cache.get('client_id')
        client_secret = self.twitch_config_cache.get('client_secret')

        if client_id and client_secret:
            self.twitch_api = TwitchApi(client_id=client_id, client_secret=client_secret)

    async def __add_already_announced(self, guild: discord.Guild, stream_id: str):
        self.already_announced_cache.add(stream_id)
        await self.config.guild(guild).already_announced.set(list(self.already_announced_cache))

    async def __get_guild_announcements(self, guild: discord.Guild):
        return await self.config.guild(guild).announcements()

    async def __get_current_announcement(self, guild: discord.Guild, user_id: str):
        cur_announcements = await self.__get_guild_announcements(guild)
        return cur_announcements.get(user_id)

    async def __add_current_announcement(self, guild: discord.Guild, role: discord.Role,
                                         channel: discord.TextChannel, user: TwitchUser):

        cur_announcements = await self.__get_guild_announcements(guild)

        metadata = {
            'twitch_name': user.display_name,
            'channel_id': channel.id,
            'role_id': role.id,
            'user_login': user.login,
            'user_thumbnail': user.profile_image_url
        }

        cur_announcements[user.id] = metadata
        # update the cache
        if not self.announce_cache.get(guild.id):
            self.announce_cache[guild.id] = {}

        if isinstance(self.announce_cache.get(guild.id), dict):
            self.announce_cache[guild.id][user.id] = metadata
        await self.config.guild(guild).announcements.set(cur_announcements)

    async def __remove_current_announcement(self, guild: discord.Guild, user_id: str):
        cur_announcements = await self.__get_guild_announcements(guild)

        removed = cur_announcements.pop(user_id)

        # update the cache
        if isinstance(self.announce_cache.get(guild.id), dict):
            self.announce_cache[guild.id].pop(user_id, None)

        if removed:
            await self.config.guild(guild).announcements.set(cur_announcements)

    def __twitch_is_init(self):
        return self.twitch_api is not None

    async def __monitor_streams(self):
        await self.bot.wait_until_ready()

        while self == self.bot.get_cog(self.__class__.__name__):

            work_list = dict()
            batch_size = 100
            to_announce = []

            # we'll batch the calls into groups of 100 (since the API allows us to ask for a max of 100 streams)
            # combine everything into one giant list of dicts
            for guild_id, guild_dict in self.announce_cache.items():
                for user_id, metadata in guild_dict.items():
                    if user_id not in work_list:
                        work_list[user_id] = {
                            'metadata': []
                        }
                    work_list[user_id]['metadata'].append(
                        {
                            'guild_id': guild_id,
                            'role_id': metadata.get('role_id'),
                            'channel_id': metadata.get('channel_id'),
                            'twitch_name': metadata.get('twitch_name'),
                            'user_login': metadata.get('user_login'),
                            'user_thumbnail': metadata.get('user_thumbnail')
                        }
                    )

            for i in range(0, len(work_list), batch_size):
                batch_user_ids = list(work_list.keys())[i:i+batch_size]

                # get streams for these user_ids
                streams = await self.twitch_api.get_streams_for_multiple(batch_user_ids)

                for stream in streams:
                    should_announce = stream.is_live and \
                                      work_list.get(stream.user_id) and \
                                      stream.id not in self.already_announced_cache

                    if should_announce:
                        announce_data = work_list[stream.user_id]['metadata']  # type: List[Dict[str, Any]]

                        for info_dict in announce_data:
                            info_dict['stream_title'] = stream.title
                            info_dict['stream_url'] = "https://twitch.tv/{}".format(info_dict.get('user_login'))
                            info_dict['stream_id'] = stream.id
                            info_dict['stream_thumbnail'] = stream.thumbnail_url

                        to_announce += announce_data
                await asyncio.sleep(self.TWITCH_API_THROTTLE)

            # process the announcement list
            for data in to_announce:

                announcement = StreamAnnouncement(bot=self.bot, **data)

                if not announcement.is_valid:
                    print("Stream announcement is not valid. Moving on...")
                    continue

                await self.__add_already_announced(guild=announcement.guild, stream_id=announcement.stream_id)
                await announcement.channel.send(content=announcement.message_content, embed=announcement.embed)

            await asyncio.sleep(self.MONITOR_PROCESS_INTERVAL)

    @staticmethod
    async def __check_announce_permissions(channel: discord.TextChannel, role: discord.Role) -> Tuple[bool, str]:

        guild = channel.guild
        bot_member = guild.me

        if channel.guild is None:
            response = (False, "❌ The specified channel is not part of a server.")
        elif channel.permissions_for(bot_member).send_messages is False:
            response = (False, "❌ The bot does not have permissions to send messages to that channel!")
        elif not role.mentionable:
            response = (False, "❌ That role is not able to be mentioned in chat.")
        else:
            response = (True, "Passed")
        return response

    @staticmethod
    def __get_role_by_id(guild: discord.guild, role_id: int) -> discord.Role:
        """
        Utility method to get a discord.py Role object from a guild by the role's ID./
        :param guild: discord.py Guild object which contains the role
        :param role_id: Integer ID of the role to retrieve
        :return: discord.py Role object for the role
        """
        return discord.utils.get(guild.roles, id=role_id)

    @commands.group(name="twitchlive", aliases=['tl'], invoke_without_command=True)
    @checks.is_owner()
    async def _twitchlive(self, ctx: Context):
        await ctx.send_help()

    @_twitchlive.command(name="configure")
    @checks.is_owner()
    async def _configure(self, ctx: Context, client_id: str, client_secret: str):
        """
        Configures the TwitchLive cog to use the specified client ID and client secret for the Twitch API.

        :param client_id: Twitch application Client ID
        :param client_secret: Twitch application Client Secret
        """

        if ctx.guild is not None and not isinstance(ctx.channel, discord.DMChannel):
            # we're not in a guild. Delete the command message if we can.
            await ctx.channel.delete_messages([ctx.message])
            return await ctx.send("For security purposes, this command must be run via whisper/DM to me.")

        new_config = {
            'client_id': client_id,
            'client_secret': client_secret
        }
        # update the cache
        current_cache = deepcopy(self.twitch_config_cache)
        current_db_config = deepcopy(await self.config.twitch_config())

        self.twitch_config_cache = new_config
        await self.config.twitch_config.set(new_config)

        # update the client with the new info
        self.__init_twitch_api()

        # do a sanity check to validate it worked
        success, exception = await self.twitch_api._sanity_check()
        if not success:
            self.twitch_config_cache = current_cache
            await self.config.twitch_config.set(current_db_config)
            return await ctx.send("{}. No changes made.".format(exception))

        await ctx.send("Successfully updated the Twitch API configuration")


    @_twitchlive.command(name="add")
    @commands.guild_only()
    @checks.is_owner()
    async def _add(self, ctx: Context, twitch_user: str, role: discord.Role, channel: discord.TextChannel):
        if not self.__twitch_is_init():
            await ctx.send("Twitch API is not initialized. Please run the `configure` sub-command.")

        success, response_msg = await self.__check_announce_permissions(channel=channel, role=role)

        if not success:
            await ctx.send(response_msg)

        twitch_user = twitch_user.lower()

        users = await self.twitch_api.get_users_by_login(username=twitch_user)

        if not users:
            return await ctx.send("That twitch user was not found")

        user = users[0]

        user_ids = await self.twitch_api.get_user_ids_for_logins([user.login])
        user_id = user_ids.get(twitch_user)

        curr_for_user = await self.__get_current_announcement(ctx.guild, user_id)
        if curr_for_user:
            role_id = curr_for_user.get('role_id')
            channel_id = curr_for_user.get('channel_id')
            return await ctx.send(f"An annoucement for that Twitch User already exists on this server. "
                                  f"Role: `{role_id}` Channel: `{channel_id}`")

        await self.__add_current_announcement(guild=ctx.guild, role=role, channel=channel, user=user)
        await ctx.send("Added announcement")

    @_twitchlive.command(name="remove")
    @commands.guild_only()
    @checks.is_owner()
    async def _remove(self, ctx: Context, twitch_user: str):
        if not self.__twitch_is_init():
            await ctx.send("Twitch API is not initialized. Please run the `configure` sub-command.")

        twitch_user = twitch_user.lower()

        user_ids = await self.twitch_api.get_user_ids_for_logins([twitch_user])
        user_id = user_ids.get(twitch_user)

        if not user_id:
            return await ctx.send("That twitch user was not found")

        curr_for_user = await self.__get_current_announcement(ctx.guild, user_id)
        if not curr_for_user:
            return await ctx.send("An announcement does not exist for that user.")

        role_id = curr_for_user.get('role_id')
        role = self.__get_role_by_id(ctx.guild, int(role_id))
        await self.__remove_current_announcement(guild=ctx.guild, user_id=user_id)
        await ctx.send(f"Removed Announcement. It was assigned to Role: `{role.name}`")
