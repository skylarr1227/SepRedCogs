import asyncio
import hashlib
import logging
import os
import re
from statistics import mean

from discord import Embed
from hurry.filesize import size as filesize
import psutil

from redbot.core import Config, checks
from redbot.core.bot import Red
from redbot.core import commands
from redbot.core.commands import Context

from .stat_helpers import StatHelpers


class BotStats(object):

    EMOJI_REGEX = re.compile("<a?:[a-zA-Z0-9_]{2,32}:(\d{1,20})>")
    CPU_MONITOR_INTERVAL = 0.2
    CPU_MONITOR_SNAPSHOT = 30
    COG_CONFIG_SALT = "twitch.tv/seputaes"

    def __init__(self, bot: Red):
        self.bot = bot
        self.config = self.__setup_config()

        self.logger = logging.getLogger("red.SepRedCogs.botstats")
        self.logger.setLevel(logging.INFO)

        self.cur_cpu_avg = 0.0

        asyncio.ensure_future(self.monitor_cpu_percent())

    async def monitor_cpu_percent(self):
        await self.bot.wait_until_ready()

        sleep_time = self.CPU_MONITOR_INTERVAL
        avg_time = self.CPU_MONITOR_SNAPSHOT
        percent_list = []

        total_time = 0

        while self == self.bot.get_cog(self.__class__.__name__):
            total_time += sleep_time

            cur_percent = psutil.cpu_percent()
            if total_time > sleep_time:  # don't include the first one since it'll likely be 0
                percent_list.append(cur_percent)

            if total_time >= avg_time:
                self.cur_cpu_avg = mean(percent_list)
                percent_list = []
            await asyncio.sleep(sleep_time)

    def __setup_config(self):
        """
        Generates an awaitable Red configuration object unique to this module.
        :return: awaitable Config
        """
        encoded_bytes = (self.COG_CONFIG_SALT + self.__class__.__name__).encode()
        identifier = int(hashlib.sha512(encoded_bytes).hexdigest(), 16)

        config = Config.get_conf(self, identifier=identifier, force_registration=False)
        self.__register_config_entities(config)

        return config

    @staticmethod
    def __register_config_entities(config: Config):
        """
        Register the configuration entities which will be used by the Cog.
        :param config: Config object generated by Config.get_conf()
        :return: None, modifies Config object in place.
        """
        pass

    @staticmethod
    def __get_bot_memory_usage() -> str:
        process = psutil.Process(os.getpid())
        mem_bytes = process.memory_info().rss

        return filesize(mem_bytes)

    @staticmethod
    def __get_sys_memory_usage() -> str:
        return filesize(psutil.virtual_memory().used)

    @commands.group(name="stats", invoke_without_command=True)
    @checks.is_owner()
    async def _stats(self, ctx: Context):

        embed = Embed(title="Security Robot System Stats",
                      description="Statistics about the bot and the system it is running on.", color=0x9400d3)

        embed.add_field(name="CPU Usage (now)", value=StatHelpers.cpu_sys_usage())
        embed.add_field(name="CPU Usage (avg 30s)", value="{}%".format(self.cur_cpu_avg))
        embed.add_field(name="Memory Usage (system)", value=StatHelpers.memory_used_over_total())
        embed.add_field(name="Memory Usage (bot)", value=StatHelpers.bot_memory_usage())
        embed.add_field(name="Uptime (system)", value=StatHelpers.system_uptime_str())
        embed.add_field(name="Uptime (bot)", value=StatHelpers.bot_uptime_str(self.bot.uptime))
        embed.add_field(name="Servers", value="{}".format(len(self.bot.guilds)))

        await ctx.send(embed=embed)

    @_stats.command(name="memory", aliases=["mem"])
    @checks.is_owner()
    async def _stat_memory(self, ctx: Context):
        process = psutil.Process(os.getpid())
        mem_bytes = process.memory_info().rss
        friendly_size = filesize(mem_bytes)

        await ctx.send(f"Bot memory usage: `{friendly_size}`")
